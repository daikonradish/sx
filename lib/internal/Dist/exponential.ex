defmodule Internal.Dist.Exponential do
  @moduledoc false
  defstruct [:lambda]

  @doc """
  refer to https://en.wikipedia.org/wiki/Exponential_distribution
  """
  @spec pdf(number(), number()) :: number()
  def pdf(lambda, x) do
    lambda * Math.exp(-lambda * x)
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Exponential_distribution
  """
  @spec cdf(number(), number()) :: number()
  def cdf(lambda, x) do
    1 - Math.exp(-lambda * x)
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Exponential_distribution
  """
  @spec icdf(number(), number()) :: number()
  def icdf(lambda, x) do
    -1 * Math.log(1 - x) / lambda
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Exponential_distribution
  """
  @spec mean(number()) :: number()
  def mean(lambda) do
    1 / lambda
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Exponential_distribution
  """
  @spec variance(number()) :: number()
  def variance(lambda) do
    1 / (lambda * lambda)
  end

  @doc """
  First argument has to be a seed generated by `Sx.Seed.new(<INTEGER>)`

  Sampling is performed by inverse transformation:
  https://en.wikipedia.org/wiki/Inverse_transform_sampling.

  Step 1: Take a random number in the unit interval.
  Step 2: Apply the inverse cdf (ppf).
  """
  def rand_gen(lambda, initial_state) do
    Rand.unit_gen_map(initial_state, fn x -> icdf(lambda, x) end)
  end
end
