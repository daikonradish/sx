defmodule Internal.Dist.ContinuousUniform do
  @moduledoc false
  defstruct [:a, :b]

  @doc """
  https://en.wikipedia.org/wiki/Continuous_uniform_distribution
  """
  @spec pdf(number(), number(), number()) :: number()
  def pdf(a, b, x) do
    if a <= x and x <= b do
      1 / (b - a)
    else
      0
    end
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Continuous_uniform_distribution
  """
  @spec cdf(number(), number(), number()) :: number()
  def cdf(a, b, x) do
    cond do
      x < a -> 0
      x > b -> 1
      true -> (x - a) / (b - a)
    end
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Continuous_uniform_distribution
  """
  @spec icdf(number(), number(), number()) :: number()
  def icdf(a, b, x) do
    a + x * (b - a)
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Continuous_uniform_distribution
  """
  @spec mean(number(), number()) :: number()
  def mean(a, b) do
    0.5 * (a + b)
  end

  @doc """
  refer to https://en.wikipedia.org/wiki/Continuous_uniform_distribution
  """
  @spec variance(number(), number()) :: number()
  def variance(a, b) do
    (b - a) * (b - a) / 12
  end

  @doc """
  First argument has to be a seed generated by `Sx.Seed.new(<INTEGER>)`

  Sampling is performed by inverse transformation:
  https://en.wikipedia.org/wiki/Inverse_transform_sampling.

  Step 1: Take a random number in the unit interval.
  Step 2: Apply the inverse cdf (ppf).
  """
  def rand_gen(a, b, initial_state) do
    Rand.unit_gen_map(initial_state, fn x -> icdf(a, b, x) end)
  end
end
